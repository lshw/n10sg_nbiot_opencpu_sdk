<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>N10SG OPENCPU MANUAL: NETWORK_FUNCTIONS</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body><script language="javascript">
        if ((window.name != "content") && (navigator.userAgent.indexOf("Opera") <= -1) )
        document.write("<center><a href='index.html?page=group___n_e_t_w_o_r_k___f_u_n_c_t_i_o_n_s.html'>show framing</a></center>")
        </script>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="1_bigpic.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">N10SG OPENCPU MANUAL
   &#160;<span id="projectnumber">V1.2.0</span>
   </div>
   <div id="projectbrief">N10SG OPENCPU SDK API使用说明 AUTHOR:XGL</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">NETWORK_FUNCTIONS<div class="ingroups"><a class="el" href="group___f_u_n_c_t_i_o_n_s.html">FUNCTIONS</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><br  />
 网络接口，TCP,UDP 收发相关函数及流程符合POSIX 标准，用户可以参照以下示例进行开发<br  />
 
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for NETWORK_FUNCTIONS:</div>
<div class="dyncontent">
<div class="center"><img src="group___n_e_t_w_o_r_k___f_u_n_c_t_i_o_n_s.png" border="0" usemap="#group______n__e__t__w__o__r__k______f__u__n__c__t__i__o__n__s" alt=""/></div>
<map name="group______n__e__t__w__o__r__k______f__u__n__c__t__i__o__n__s" id="group______n__e__t__w__o__r__k______f__u__n__c__t__i__o__n__s">
<area shape="rect" title="网络接口，TCP,UDP 收发相关函数及流程符合POSIX 标准，用户可以参照以下示例进行开发" alt="" coords="148,5,316,31"/>
<area shape="rect" href="group___f_u_n_c_t_i_o_n_s.html" title="opencpu SDK开放的函数接口" alt="" coords="5,5,100,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab9389b81d76f40cdc9c2defd811177bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_e_t_w_o_r_k___f_u_n_c_t_i_o_n_s.html#gab9389b81d76f40cdc9c2defd811177bb">opencpu_ping</a> (unsigned char *remote, int count, int pktsz, ping_request_result_t callback)</td></tr>
<tr class="separator:gab9389b81d76f40cdc9c2defd811177bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b347e7996e54771450981de0d7e003e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_e_t_w_o_r_k___f_u_n_c_t_i_o_n_s.html#ga5b347e7996e54771450981de0d7e003e">opencpu_get_host_by_name</a> (unsigned char *domain_name, unsigned char *server_ip, dns_request_result_t test_dns_cb)</td></tr>
<tr class="separator:ga5b347e7996e54771450981de0d7e003e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><br  />
 网络接口，TCP,UDP 收发相关函数及流程符合POSIX 标准，用户可以参照以下示例进行开发<br  />
</p>
<pre>
<div class="fragment"><div class="line">   TCP测试：</div>
<div class="line">   <span class="keywordtype">void</span> tcp_test()</div>
<div class="line">   {</div>
<div class="line">    <span class="keyword">struct </span>sockaddr_in server_addr;  </div>
<div class="line">    <span class="keywordtype">int</span> sock_fd;  </div>
<div class="line">    <span class="keywordtype">int</span> data_len;</div>
<div class="line">    <span class="comment">//填入服务器地址、端口</span></div>
<div class="line">    inet_aton(<span class="stringliteral">&quot;47.93.217.230&quot;</span>, &amp;test_remote_addr);  </div>
<div class="line">    test_remote_port = 2019;</div>
<div class="line">    <span class="comment">//创建TCP类型socket</span></div>
<div class="line">    sock_fd = socket(AF_INET, SOCK_STREAM, 0);  </div>
<div class="line">    <span class="keywordflow">if</span> (sock_fd == -1) {  </div>
<div class="line">        opencpu_printf ( <span class="stringliteral">&quot;socket create error\n&quot;</span>);</div>
<div class="line">         <span class="keywordflow">return</span>;</div>
<div class="line">    }  </div>
<div class="line">    memset(&amp;server_addr, 0, <span class="keyword">sizeof</span>(server_addr));</div>
<div class="line">    填充服务器地址信息结构体</div>
<div class="line">    server_addr.sin_family = AF_INET;  </div>
<div class="line">    server_addr.sin_addr.s_addr = test_remote_addr.s_addr;</div>
<div class="line">    server_addr.sin_port = htons(test_remote_port);</div>
<div class="line">    <span class="comment">//连接到TCP服务器</span></div>
<div class="line">    <span class="keywordflow">if</span>(connect(sock_fd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr)))</div>
<div class="line">    {</div>
<div class="line">        opencpu_printf ( <span class="stringliteral">&quot;tcp connect error\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">        opencpu_printf ( <span class="stringliteral">&quot;tcp data sending\n&quot;</span>);</div>
<div class="line">        <span class="comment">//发送数据到服务器</span></div>
<div class="line">        send(sock_fd, (<span class="keywordtype">char</span> *)test_msg, <span class="keyword">sizeof</span>(test_msg), 0);</div>
<div class="line">        memset(test_rx_buf,0,100);</div>
<div class="line">        <span class="comment">//下面这句已被注释，用于非阻塞方式接收数据，无数据可收则立即返回</span></div>
<div class="line">        <span class="comment">//data_len = recvfrom(sock_fd, test_rx_buf,</span></div>
<div class="line">                  <span class="comment">//  100, MSG_TRUNC | MSG_DONTWAIT, (struct sockaddr*)&amp;from, &amp;fromlen);</span></div>
<div class="line">        opencpu_printf ( <span class="stringliteral">&quot;tcp waiting...\n&quot;</span>);</div>
<div class="line">        <span class="comment">//阻塞方式等待服务器返回数据</span></div>
<div class="line">        data_len = recv(sock_fd, test_rx_buf,100, MSG_TRUNC);</div>
<div class="line">        opencpu_printf ( <span class="stringliteral">&quot;waiting end\n&quot;</span>);</div>
<div class="line">        <span class="comment">//打印出接收到的数据信息     </span></div>
<div class="line">        <span class="keywordflow">if</span>(data_len &gt;0)</div>
<div class="line">        {</div>
<div class="line">            opencpu_printf (<span class="stringliteral">&quot;get:%s\n&quot;</span>,test_rx_buf);</div>
<div class="line">            opencpu_printf ( <span class="stringliteral">&quot;len:%d\n&quot;</span>,data_len);           </div>
<div class="line">        }</div>
<div class="line">        opencpu_printf ( <span class="stringliteral">&quot;tcp waiting..1.\n&quot;</span>);</div>
<div class="line">        <span class="comment">//再次阻塞等待服务器数据</span></div>
<div class="line">        data_len = recv(sock_fd, test_rx_buf,100, MSG_TRUNC);</div>
<div class="line">        opencpu_printf ( <span class="stringliteral">&quot;waiting end1\n&quot;</span>);</div>
<div class="line">        <span class="comment">//打印出接收到的数据信息</span></div>
<div class="line">        <span class="keywordflow">if</span>(data_len &gt;0)</div>
<div class="line">        {</div>
<div class="line">            opencpu_printf (<span class="stringliteral">&quot;get:%s\n&quot;</span>,test_rx_buf);</div>
<div class="line">            opencpu_printf ( <span class="stringliteral">&quot;len:%d\n&quot;</span>,data_len);           </div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">    close(sock_fd);</div>
<div class="line">    </div>
<div class="line">    }</div>
<div class="line">    UDP测试：</div>
<div class="line">    <span class="keywordtype">void</span> udp_test()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>sockaddr_in server_addr;</div>
<div class="line">    <span class="keywordtype">int</span> sock_fd; </div>
<div class="line">    <span class="keyword">struct </span>sockaddr_in from;</div>
<div class="line">    <span class="keywordtype">int</span> data_len;</div>
<div class="line">    <span class="keyword">struct </span>in_addr test_remote_addr;</div>
<div class="line">uint16_t test_remote_port;</div>
<div class="line"><span class="comment">//填入要发送数据的IP地址</span></div>
<div class="line">    inet_aton(<span class="stringliteral">&quot;47.93.217.230&quot;</span>, &amp;test_remote_addr);  </div>
<div class="line">    <span class="comment">//要发送数据的端口</span></div>
<div class="line">    test_remote_port = 2019;    </div>
<div class="line">    socklen_t fromlen = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_in);</div>
<div class="line">    <span class="comment">//创建UDP类型的socket</span></div>
<div class="line">    sock_fd = socket(AF_INET, SOCK_DGRAM, 0);</div>
<div class="line">    <span class="keywordflow">if</span>(sock_fd == -1)</div>
<div class="line">    {</div>
<div class="line">        opencpu_printf ( <span class="stringliteral">&quot;socket create error\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    memset(&amp;server_addr, 0, <span class="keyword">sizeof</span>(server_addr)); </div>
<div class="line">    <span class="comment">//填充地址结构体</span></div>
<div class="line">    server_addr.sin_family = AF_INET;  </div>
<div class="line">    server_addr.sin_addr.s_addr = test_remote_addr.s_addr;  </div>
<div class="line">    server_addr.sin_port = htons(test_remote_port);  </div>
<div class="line">   <span class="comment">//UDP中该连接函数只完成一些本地操作，传入一些参数</span></div>
<div class="line">    connect(sock_fd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr)); </div>
<div class="line">    opencpu_printf (<span class="stringliteral">&quot;data sending\n&quot;</span>);</div>
<div class="line">    <span class="comment">//UDP发送数据</span></div>
<div class="line">    send(sock_fd, (<span class="keywordtype">char</span> *)test_msg, <span class="keyword">sizeof</span>(test_msg), 0);</div>
<div class="line">     memset(test_rx_buf,0,100);</div>
<div class="line">    <span class="comment">//这一句被注释掉了，这是非阻塞方式接受数据，如果没有数据可收，则立即返回</span></div>
<div class="line">    <span class="comment">//data_len = recvfrom(sock_fd, test_rx_buf,</span></div>
<div class="line">                   <span class="comment">// 100, MSG_TRUNC | MSG_DONTWAIT, (struct sockaddr*)&amp;from, &amp;fromlen);</span></div>
<div class="line">    opencpu_printf ( <span class="stringliteral">&quot;waiting...\n&quot;</span>);</div>
<div class="line">    <span class="comment">//这是阻塞方式接受数据，会阻塞等到数据到来才返回</span></div>
<div class="line">    data_len = recvfrom(sock_fd, test_rx_buf,</div>
<div class="line">                    100, MSG_TRUNC, (<span class="keyword">struct</span> sockaddr*)&amp;from, &amp;fromlen);</div>
<div class="line">    opencpu_printf(<span class="stringliteral">&quot;waiting end\n&quot;</span>);   </div>
<div class="line">    <span class="comment">//在串口打印出服务器返回的数据信息                </span></div>
<div class="line">    <span class="keywordflow">if</span>(data_len &gt;0)</div>
<div class="line">        {</div>
<div class="line">            opencpu_printf ( <span class="stringliteral">&quot;get:%s\n&quot;</span>,test_rx_buf);</div>
<div class="line">            opencpu_printf ( <span class="stringliteral">&quot;len:%d\n&quot;</span>,data_len);           </div>
<div class="line">        }</div>
<div class="line">    <span class="comment">//关闭socket</span></div>
<div class="line">    close(sock_fd); </div>
<div class="line">   }</div>
</div><!-- fragment -->
  </pre> <h2 class="groupheader">Function Documentation</h2>
<a id="ga5b347e7996e54771450981de0d7e003e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b347e7996e54771450981de0d7e003e">&#9670;&nbsp;</a></span>opencpu_get_host_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opencpu_get_host_by_name </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>domain_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>server_ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dns_request_result_t&#160;</td>
          <td class="paramname"><em>test_dns_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">\brief 执行域名解析功能

\param [in] domain_name 要解析的域名字符串
\param [in] server_ip 域名解析服务器IP地址
\param [in] test_dns_cb 回调函数
\return 0：成功 -1：失败

示例：下面测试获取百度的IP地址，填写域名；第二个参数是DNS服务器IP，没有就填0；最后是回调函数
@code 
opencpu_get_host_by_name("www.baidu.com",0,test_cmdns_cb)
@endcode
回调函数的写法如下：
@code
</pre><p> void test_cmdns_cb(unsigned char *ip) { </p><pre class="fragment">opencpu_printf ("opencpu dns:%s\n",ip); 
</pre><p> } </p><pre class="fragment">@endcode
</pre> 
</div>
</div>
<a id="gab9389b81d76f40cdc9c2defd811177bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9389b81d76f40cdc9c2defd811177bb">&#9670;&nbsp;</a></span>opencpu_ping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opencpu_ping </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>remote</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pktsz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ping_request_result_t&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">\brief 执行PING功能

\param [in] remote remote IP
\param [in] count 要发送的包个数
\param [in] pktsz 每个包的大小
\param [in] callback 执行结果的回调函数
\return 空

示例：下面测试180.97.33.108的可达性，发三个包，包携带64个字节的数据
@code

opencpu_ping("180.97.33.108",3,64,test_ping_cb);
void test_ping_cb(ping_result_type_t type, void* p)
</pre><p> { switch(type) { case PING_TOTAL_RESULT: { if (p) { ping_result_t* ping_result = (ping_result_t*)p; opencpu_printf ("\r\n--- %s ping statistics ---\r\n" "%d packets transmitted, %d received, %d%% packet loss\r\n" "rtt min/avg/max = %d/%d/%d", inet_ntoa(ping_result-&gt;ping_target), (int)ping_result-&gt;total_num, (int)ping_result-&gt;recv_num, (int)((ping_result-&gt;lost_num * 100)/ping_result-&gt;total_num), ping_result-&gt;min_time,ping_result-&gt;avg_time,ping_result-&gt;max_time);</p>
<p>} else { break;//response.pdata = "+Ping: finish, no result!"; } } break; case PING_PACKET_RESULT: { ping_packet_result_t* ping_result = (ping_packet_result_t*)p; if (p == NULL) { break; } else if (ping_result-&gt;is_timeout == true) { opencpu_printf ("+PINGERR: 1"); break; } else { if (ping_result-&gt;is_ipv4 == true) { opencpu_printf ("+PING: %d.%d.%d.%d,%d,%d",ping_result-&gt;ip_address[0], ping_result-&gt;ip_address[1], ping_result-&gt;ip_address[2], ping_result-&gt;ip_address[3], ping_result-&gt;ttl,ping_result-&gt;rtt); } else { opencpu_printf ("+PING: %x:%x:%x:%x:%x:%x:%x:%x,%d,%d",ping_result-&gt;ip_address[0], ping_result-&gt;ip_address[1],ping_result-&gt;ip_address[2], ping_result-&gt;ip_address[3], ping_result-&gt;ip_address[4],ping_result-&gt;ip_address[5], ping_result-&gt;ip_address[6],ping_result-&gt;ip_address[7], ping_result-&gt;ttl,ping_result-&gt;rtt); } } } break; } } </p><pre class="fragment">@endcode
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
